/*
 * APA Prefetcher
 *
 * Pattern table
 * The pattern table is indexed by the history signatures generated by the ST
 * and sotres predicted delta patterns. The PT also estimates the path confidence
 * that a given delta pattern will yeld a useful prefetch.
 * Unlike ST, whose entries corresponds to individual physical pages, each PT
 * entry is shared globally by all pages. So if page A and page B share the same
 * access pattern, they will generate the same signature, which indexes the same
 * PT entry.
 */

#include <pt.h>

void pt_init()
{
    int i;
    for (i=0; i<N_PT_ENTRIES; ++i)
    {
        PT[i].c_sig=0;
        int j;
        for (j=0; j<N_PT_DELTAS_PER_ENTRY; ++j)
        {
            PT[i].c_delta[j]=0;
            PT[i].valid[j]=0;
        }
    }
}

void pt_update(SIGNATURE_FIELD signature, 7BIT_FIELD delta)
{
    int index=signature%N_PT_ENTRIES;
    pattern_table_entry_t *entry=&PT[index];

    BOOL done=FALSE;
    4BIT_FIELD min_c_delta=0xF;
    int min_c_delta_index=NULL;

    int j;
    for (j=0; j<N_PT_DELTAS_PER_ENTRY && !done; ++j)
    {
        if (!entry->valid[j])
        {
            entry->delta[j]=delta;
            entry->c_delta[j]=1;
            entry->valid=1;
            done=TRUE;
        }
        else if (entry->delta[j] == delta)
        {
            entry->c_delta[j]+=1;
            done=TRUE;
        }
        else if (entry->delta[j] < min_c_delta)
        {
            min_c_delta=entry->delta[j];
            min_c_delta_index=j;
        }
    }

    if (!done) // Replace delta with less confident
    {
        assert(min_c_delta_index != NULL);
        entry->c_sig-=entry->c_delta[min_c_delta_index];
        entry->delta[min_c_delta_index]=delta;
        entry->c_delta[min_c_delta_index]=1;
    }

    entry->c_sig+=1;
}

int pt_get_deltas(SIGNATURE_FIELD signature, double c_threshold, 
        7BIT_FIELD *delta, double *c)
{
    int index=signature%N_PT_ENTRIES;
    pattern_table_entry_t *entry=&PT[index];
    delta = malloc(N_PT_DELTAS_PER_ENTRY*sizeof(4BIT_FIELD));
    c = malloc(N_PT_DELTAS_PER_ENTRY*sizeof(double));
    int n_deltas=0;

    int i;
    for (i=0; i<N_PT_DELTAS_PER_ENTRY; ++i)
    {
        double confidence=entry->c_delta[i]/entry->c_sig;
        if (confidence >= c_threshold)
        {
            delta[n_deltas]=entry->delta[i];
            c[n_deltas]=confidence;
            n_deltas++;
        }
    }

    return n_deltas;
}
